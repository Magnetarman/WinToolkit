# GitHub Actions Workflow per Continuous Integration con Test PowerShell
# Questo workflow esegue test estesi di tutti gli script PowerShell nella cartella /tool
# e gestisce l'aggiornamento automatico di WinToolkit.ps1 sul branch dev

name: CI_UpdateWinToolkit_Dev

# Configurazione del trigger: il workflow si attiva solo sui push al branch 'dev'
# Questo garantisce che l'azione sia esclusiva per il ramo di sviluppo
on:
  push:
    branches: [Dev]

# Definizione dei job del workflow
jobs:
  # Job principale che gestisce build e commit automatico
  build_and_commit:
    # Esecuzione su macchina virtuale Ubuntu (ultima versione stabile)
    runs-on: ubuntu-latest

    # Configurazione dei permessi necessari per il workflow
    permissions:
      contents: write
      actions: read

    # Definizione dei passi sequenziali del job
    steps:
      # Step 1: Checkout del codice sorgente
      # Utilizza l'azione ufficiale per clonare il repository
      - name: Checkout del repository
        uses: actions/checkout@v4
        with:
          # Utilizza il token GitHub predefinito con i permessi necessari
          token: ${{ secrets.GITHUB_TOKEN }}
          # Fetch completo necessario per il commit
          fetch-depth: 0

      # Step 2: Test estesi di tutti gli script PowerShell nella cartella /tool
      # Verifica sintassi, logica e struttura per evitare push di codice non funzionante
      - name: Test Estesi PowerShell
        shell: pwsh
        run: |
          Write-Host "üîç INIZIO TEST ESTESI POWERSHELL" -ForegroundColor Cyan
          Write-Host "=" * 70 -ForegroundColor Yellow

          $toolPath = "tool"
          $scriptFiles = Get-ChildItem -Path $toolPath -Name "*.ps1" -Recurse

          if ($scriptFiles.Count -eq 0) {
            Write-Error "‚ùå Nessun file PowerShell trovato nella cartella $toolPath"
            exit 1
          }

          Write-Host "üìã Script da testare ($($scriptFiles.Count)):" -ForegroundColor Green
          $scriptFiles | ForEach-Object { Write-Host "  - $_" -ForegroundColor Gray }

          $totalErrors = 0

          foreach ($file in $scriptFiles) {
            $fullPath = Join-Path $toolPath $file
            Write-Host "üîç Testing: $file" -ForegroundColor Blue

            try {
              # Test sintassi
              $scriptContent = Get-Content -Raw -Path $fullPath
              $parseErrors = $null
              $null = [System.Management.Automation.Language.Parser]::ParseInput($scriptContent, [ref]$null, [ref]$parseErrors)

              if ($parseErrors.Count -gt 0) {
                Write-Host "  ‚ùå Errori di sintassi in $file" -ForegroundColor Red
                $parseErrors | ForEach-Object { Write-Host "    $($_.Message)" -ForegroundColor Red }
                $totalErrors += $parseErrors.Count
              }
              else {
                Write-Host "  ‚úÖ Sintassi OK" -ForegroundColor Green
              }

              # Test presenza funzioni principali
              $functions = [System.Management.Automation.Language.Parser]::ParseInput($scriptContent, [ref]$null, [ref]$null) |
                          Where-Object { $_.GetType().Name -eq "FunctionDefinitionAst" }

              if ($functions.Count -gt 0) {
                Write-Host "  üìã Funzioni: $($functions.Count)" -ForegroundColor Gray
              }
              else {
                Write-Host "  ‚ö†Ô∏è Nessuna funzione trovata" -ForegroundColor Yellow
              }

            }
            catch {
              Write-Host "  ‚ùå Errore nel test di $file`: $($_.Exception.Message)" -ForegroundColor Red
              $totalErrors++
            }
          }

          if ($totalErrors -gt 0) {
            Write-Host "‚ùå TEST FALLITI: $totalErrors errori trovati" -ForegroundColor Red
            Write-Host "üí° Verifica la sintassi degli script PowerShell" -ForegroundColor Cyan
            exit 1
          }

          Write-Host "‚úÖ TUTTI I TEST SUPERATI!" -ForegroundColor Green

      # Step 3: Configurazione dell'ambiente PowerShell e Node.js
      # Installa Node.js che √® necessario per molti runner di GitHub Actions
      - name: Setup Node.js per l'ambiente
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      # Step 4: Verifica e configurazione PowerShell
      # Assicura che PowerShell sia disponibile e configurato correttamente
      - name: Configurazione PowerShell
        run: |
          # Verifica che PowerShell sia installato e funzionante
          pwsh --version
          # Imposta i permessi di esecuzione per lo script
          chmod +x ./compiler.ps1

      # Step 5: Esecuzione dello script compiler.ps1
      # Questo script genera il file WinToolkit.ps1 come output
      - name: Esecuzione script compiler.ps1
        run: ./compiler.ps1
        shell: pwsh

      # Step 6: Controllo di sintassi del file generato
      # Verifica la correttezza sintattica di WinToolkit.ps1 prima del commit
      - name: Controllo sintassi WinToolkit.ps1
        shell: pwsh
        run: |
          # Controllo sintattico usando l'AST di PowerShell
          try {
            # Verifica che il file esista
            if (-not (Test-Path './WinToolkit.ps1')) {
              throw 'File WinToolkit.ps1 non trovato'
            }
            
            # Usa l'AST (Abstract Syntax Tree) per controllare la sintassi
            $scriptContent = Get-Content -Raw -Path './WinToolkit.ps1'
            $errors = @()
            $null = [System.Management.Automation.Language.Parser]::ParseInput($scriptContent, [ref]$null, [ref]$errors)
            
            if ($errors.Count -gt 0) {
              Write-Host 'Errori di sintassi trovati:'
              $errors | ForEach-Object { Write-Host "- $($_.Message)" }
              throw 'Controllo sintassi fallito'
            } else {
              Write-Host 'Controllo sintassi completato con successo - Nessun errore trovato'
            }
          } catch {
            Write-Error $_.Exception.Message
            exit 1
          }

      # Step 7: Commit automatico del file aggiornato
      # Utilizza azione specializzata per commit e push automatici
      - name: Commit automatico WinToolkit.ps1
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          # Messaggio del commit standardizzato
          commit_message: "Update Wintoolkit-Dev"
          # Specifica solo il file da committare per evitare commit indesiderati
          file_pattern: WinToolkit.ps1
          # Branch di destinazione (deve corrispondere al branch corrente)
          branch: Dev
