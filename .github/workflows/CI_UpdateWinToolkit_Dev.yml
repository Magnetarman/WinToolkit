# GitHub Actions Workflow per Continuous Integration con Test PowerShell
# Questo workflow si attiva solo quando vengono modificati file .ps1 nella cartella /tool
# Compila automaticamente WinToolkit.ps1 e testa il risultato prima di committare

name: CI_UpdateWinToolkit_Dev

# Configurazione del trigger: si attiva solo su modifiche a file .ps1 nella cartella /tool
on:
  push:
    branches: [Dev]
    paths:
      - "tool/*.ps1"
      - "WinToolkit-template.ps1"
      - "compiler.ps1"

# Definizione dei job del workflow
jobs:
  # Job principale che gestisce compilazione, test e commit automatico
  compile_test_and_commit:
    # Esecuzione su macchina virtuale Windows (ultima versione stabile)
    runs-on: windows-latest

    # Configurazione dei permessi necessari per il workflow
    permissions:
      contents: write
      actions: read

    # Definizione dei passi sequenziali del job
    steps:
      # Step 1: Checkout del codice sorgente con fetch completo per analizzare i commit
      - name: Checkout del repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      # Step 2: Verifica se ci sono modifiche rilevanti ai file PowerShell
      - name: Verifica modifiche rilevanti
        id: check_changes
        shell: pwsh
        run: |
          Write-Host "ğŸ” VERIFICA MODIFICHE RILEVANTI" -ForegroundColor Cyan
          Write-Host "=" * 60 -ForegroundColor Yellow

          # Lista dei file che dovrebbero triggerare il workflow
          $relevantPaths = @(
            "tool/*.ps1",
            "WinToolkit-template.ps1",
            "compiler.ps1"
          )

          # Ottieni i file modificati nell'ultimo commit
          $changedFiles = git diff --name-only HEAD~1 HEAD

          if ($changedFiles.Count -eq 0) {
            Write-Host "â„¹ï¸ Nessun file modificato nel commit corrente" -ForegroundColor Yellow
            Write-Host "âœ… Workflow completato senza azioni necessarie" -ForegroundColor Green
            exit 0
          }

          Write-Host "ğŸ“‹ File modificati nell'ultimo commit:" -ForegroundColor Green
          $changedFiles | ForEach-Object { Write-Host "  - $_" -ForegroundColor Gray }

          # Verifica se almeno uno dei file modificati Ã¨ rilevante
          $hasRelevantChanges = $false
          foreach ($file in $changedFiles) {
            foreach ($pattern in $relevantPaths) {
              if ($file -like $pattern) {
                $hasRelevantChanges = $true
                break
              }
            }
            if ($hasRelevantChanges) { break }
          }

          if (-not $hasRelevantChanges) {
            Write-Host "â„¹ï¸ Nessuna modifica rilevante per questo workflow" -ForegroundColor Yellow
            Write-Host "âœ… Workflow completato senza azioni necessarie" -ForegroundColor Green
            exit 0
          }

          Write-Host "âœ… Modifiche rilevanti rilevate - procedo con compilazione e test" -ForegroundColor Green
          Write-Output "has_relevant_changes=true" >> $env:GITHUB_OUTPUT

      # Step 3: Configurazione ambiente PowerShell
      - name: Setup PowerShell
        shell: pwsh
        run: |
          Write-Host "ğŸ”§ CONFIGURAZIONE AMBIENTE POWERSHELL" -ForegroundColor Cyan
          $PSVersionTable
          Write-Host "âœ… PowerShell configurato" -ForegroundColor Green

      # Step 3b: Test sintassi file sorgenti PRIMA della compilazione
      - name: Test Sintassi File Sorgenti
        if: steps.check_changes.outputs.has_relevant_changes == 'true'
        shell: pwsh
        run: |
          Write-Host "ğŸ” TEST SINTASSI FILE SORGENTI" -ForegroundColor Cyan
          Write-Host "=" * 70 -ForegroundColor Yellow

          $hasErrors = $false
          $errorDetails = @()

          # Test compiler.ps1
          Write-Host "`nğŸ“„ Test: compiler.ps1" -ForegroundColor Blue
          if (Test-Path "compiler.ps1") {
            try {
              $content = Get-Content -Raw -Path "compiler.ps1" -ErrorAction Stop
              $parseErrors = $null
              $null = [System.Management.Automation.Language.Parser]::ParseInput($content, [ref]$null, [ref]$parseErrors)

              if ($parseErrors.Count -gt 0) {
                Write-Host "  âŒ Errori di sintassi trovati:" -ForegroundColor Red
                foreach ($error in $parseErrors) {
                  $errorMsg = "  â†’ Linea $($error.Extent.StartLineNumber), Colonna $($error.Extent.StartColumnNumber): $($error.Message)"
                  Write-Host $errorMsg -ForegroundColor Red
                  $errorDetails += "compiler.ps1: $errorMsg"
                }
                $hasErrors = $true
              } else {
                Write-Host "  âœ… Sintassi corretta" -ForegroundColor Green
              }
            } catch {
              Write-Host "  âŒ Errore lettura file: $($_.Exception.Message)" -ForegroundColor Red
              $errorDetails += "compiler.ps1: Errore lettura - $($_.Exception.Message)"
              $hasErrors = $true
            }
          }

          # Test WinToolkit-template.ps1
          Write-Host "`nğŸ“„ Test: WinToolkit-template.ps1" -ForegroundColor Blue
          if (Test-Path "WinToolkit-template.ps1") {
            try {
              $content = Get-Content -Raw -Path "WinToolkit-template.ps1" -ErrorAction Stop
              $parseErrors = $null
              $null = [System.Management.Automation.Language.Parser]::ParseInput($content, [ref]$null, [ref]$parseErrors)

              if ($parseErrors.Count -gt 0) {
                Write-Host "  âŒ Errori di sintassi trovati:" -ForegroundColor Red
                foreach ($error in $parseErrors) {
                  $errorMsg = "  â†’ Linea $($error.Extent.StartLineNumber), Colonna $($error.Extent.StartColumnNumber): $($error.Message)"
                  Write-Host $errorMsg -ForegroundColor Red
                  $errorDetails += "WinToolkit-template.ps1: $errorMsg"
                }
                $hasErrors = $true
              } else {
                Write-Host "  âœ… Sintassi corretta" -ForegroundColor Green
              }
            } catch {
              Write-Host "  âŒ Errore lettura file: $($_.Exception.Message)" -ForegroundColor Red
              $errorDetails += "WinToolkit-template.ps1: Errore lettura - $($_.Exception.Message)"
              $hasErrors = $true
            }
          }

          # Test tutti i file .ps1 nella cartella tool
          Write-Host "`nğŸ“ Test: File in cartella tool/" -ForegroundColor Blue
          $toolFiles = Get-ChildItem -Path "tool" -Filter "*.ps1" -ErrorAction SilentlyContinue

          foreach ($file in $toolFiles) {
            Write-Host "`n  ğŸ“„ Test: $($file.Name)" -ForegroundColor Cyan
            try {
              $content = Get-Content -Raw -Path $file.FullName -ErrorAction Stop
              $parseErrors = $null
              $null = [System.Management.Automation.Language.Parser]::ParseInput($content, [ref]$null, [ref]$parseErrors)

              if ($parseErrors.Count -gt 0) {
                Write-Host "    âŒ Errori di sintassi trovati:" -ForegroundColor Red
                foreach ($error in $parseErrors) {
                  $errorMsg = "    â†’ Linea $($error.Extent.StartLineNumber), Colonna $($error.Extent.StartColumnNumber): $($error.Message)"
                  Write-Host $errorMsg -ForegroundColor Red
                  $errorDetails += "$($file.Name): $errorMsg"
                }
                $hasErrors = $true
              } else {
                Write-Host "    âœ… Sintassi corretta" -ForegroundColor Green
              }
            } catch {
              Write-Host "    âŒ Errore lettura file: $($_.Exception.Message)" -ForegroundColor Red
              $errorDetails += "$($file.Name): Errore lettura - $($_.Exception.Message)"
              $hasErrors = $true
            }
          }

          # Riepilogo errori
          if ($hasErrors) {
            Write-Host "`nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—" -ForegroundColor Red
            Write-Host "â•‘           âŒ ERRORI DI SINTASSI TROVATI              â•‘" -ForegroundColor Red
            Write-Host "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•" -ForegroundColor Red
            Write-Host "`nğŸ“‹ RIEPILOGO ERRORI:" -ForegroundColor Yellow
            foreach ($detail in $errorDetails) {
              Write-Host $detail -ForegroundColor Red
            }
            Write-Host "`nğŸ’¡ Correggi gli errori di sintassi prima di procedere" -ForegroundColor Cyan
            exit 1
          } else {
            Write-Host "`nâœ… TUTTI I FILE HANNO SINTASSI CORRETTA" -ForegroundColor Green
          }

      # Step 4: Incremento automatico del numero di build
      - name: Incrementa Numero Build
        id: increment_version
        if: steps.check_changes.outputs.has_relevant_changes == 'true'
        shell: pwsh
        run: |
          Write-Host "ğŸ“ˆ INCREMENTO NUMERO BUILD" -ForegroundColor Cyan
          Write-Host "=" * 60 -ForegroundColor Yellow

          $templatePath = "WinToolkit-template.ps1"

          # Verifica che il file esista
          if (-not (Test-Path $templatePath)) {
            Write-Error "âŒ File $templatePath non trovato"
            exit 1
          }

          # Leggi il contenuto del file
          $content = Get-Content -Path $templatePath -Raw

          # Trova la riga con la versione e estrai il numero di build
          $versionPattern = '\$ToolkitVersion\s*=\s*["\'](.+?)["\']'
          if ($content -match $versionPattern) {
            $fullVersion = $matches[1]
            Write-Host "ğŸ“‹ Versione attuale: $fullVersion" -ForegroundColor Green
            
            # Estrai il numero di build (numero alla fine tra parentesi)
            $buildPattern = 'Build\s+(\d+)'
            if ($fullVersion -match $buildPattern) {
              $currentBuild = [int]$matches[1]
              $newBuild = $currentBuild + 1
              $newVersion = $fullVersion -replace "Build\s+$currentBuild", "Build $newBuild"
              
              Write-Host "ğŸ”„ Incremento build: $currentBuild â†’ $newBuild" -ForegroundColor Blue
              Write-Host "ğŸ†• Nuova versione: $newVersion" -ForegroundColor Green
              
              # Sostituisci la riga della versione
              $newLine = "`$ToolkitVersion = \"$newVersion\""
              $content = $content -replace "\$ToolkitVersion\s*=\s*[\"\'].+?[\"\']", $newLine
              
              # Scrivi il file aggiornato
              $content | Set-Content -Path $templatePath -Encoding UTF8
              
              Write-Host "âœ… Versione incrementata con successo" -ForegroundColor Green
              Write-Output "new_version=$newVersion" >> $env:GITHUB_OUTPUT
              Write-Output "build_number=$newBuild" >> $env:GITHUB_OUTPUT
            }
            else {
              Write-Error "âŒ Impossibile trovare il numero di build nella versione"
              exit 1
            }
          }
          else {
            Write-Error "âŒ Impossibile trovare la riga della versione nel template"
            exit 1
          }

      # Step 5: Commit del template con versione incrementata
      - name: Commit Template Aggiornato
        if: steps.check_changes.outputs.has_relevant_changes == 'true'
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: |
            ğŸ”– Bump WinToolkit version to ${{ steps.increment_version.outputs.new_version }}

            â€¢ Incremento automatico numero build
            â€¢ Versione aggiornata nel template
          file_pattern: WinToolkit-template.ps1
          branch: Dev

      # Step 6: Compilazione WinToolkit.ps1 tramite compiler.ps1 con debugging migliorato
      - name: Compilazione WinToolkit.ps1
        if: steps.check_changes.outputs.has_relevant_changes == 'true'
        shell: pwsh
        run: |
          Write-Host "ğŸ”¨ COMPILAZIONE WINTOOLKIT.PS1" -ForegroundColor Cyan
          Write-Host "=" * 60 -ForegroundColor Yellow

          # Verifica che compiler.ps1 esista
          if (-not (Test-Path "compiler.ps1")) {
            Write-Error "âŒ File compiler.ps1 non trovato"
            exit 1
          }

          # Verifica che WinToolkit-template.ps1 esista
          if (-not (Test-Path "WinToolkit-template.ps1")) {
            Write-Error "âŒ File WinToolkit-template.ps1 non trovato"
            exit 1
          }

          # Verifica che ci siano file .ps1 nella cartella tool
          $toolFiles = Get-ChildItem -Path "tool" -Filter "*.ps1" -ErrorAction SilentlyContinue
          if ($toolFiles.Count -eq 0) {
            Write-Error "âŒ Nessun file .ps1 trovato nella cartella tool"
            exit 1
          }

          Write-Host "ğŸ“‹ File da compilare: $($toolFiles.Count)" -ForegroundColor Green
          $toolFiles | ForEach-Object { Write-Host "  - $($_.Name)" -ForegroundColor Gray }

          # Esegui la compilazione con cattura output dettagliato
          Write-Host "`nğŸ”„ Esecuzione compilazione..." -ForegroundColor Blue
          try {
            # Esegui e cattura tutto l'output
            $output = & ".\compiler.ps1" 2>&1 | Out-String

            # Mostra l'output
            Write-Host $output

            # Controlla il risultato
            if ($LASTEXITCODE -ne 0) {
              Write-Host "`nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—" -ForegroundColor Red
              Write-Host "â•‘        âŒ COMPILAZIONE FALLITA                        â•‘" -ForegroundColor Red
              Write-Host "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•" -ForegroundColor Red
              Write-Host "`nExit Code: $LASTEXITCODE" -ForegroundColor Red
              Write-Host "`nğŸ’¡ Verifica l'output sopra per dettagli sull'errore" -ForegroundColor Cyan
              exit 1
            }
          }
          catch {
            Write-Host "`nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—" -ForegroundColor Red
            Write-Host "â•‘     âŒ ERRORE DURANTE LA COMPILAZIONE                 â•‘" -ForegroundColor Red
            Write-Host "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•" -ForegroundColor Red
            Write-Host "`nğŸ“‹ Dettagli errore:" -ForegroundColor Yellow
            Write-Host "Messaggio: $($_.Exception.Message)" -ForegroundColor Red
            Write-Host "Tipo: $($_.Exception.GetType().FullName)" -ForegroundColor Red
            if ($_.InvocationInfo) {
              Write-Host "Linea: $($_.InvocationInfo.ScriptLineNumber)" -ForegroundColor Red
              Write-Host "Comando: $($_.InvocationInfo.Line)" -ForegroundColor Red
            }
            if ($_.ScriptStackTrace) {
              Write-Host "`nStack Trace:" -ForegroundColor Yellow
              Write-Host $_.ScriptStackTrace -ForegroundColor Red
            }
            exit 1
          }

          # Verifica che il file compilato sia stato creato
          if (-not (Test-Path "WinToolkit.ps1")) {
            Write-Host "`nâŒ File WinToolkit.ps1 non creato dalla compilazione" -ForegroundColor Red
            Write-Host "ğŸ’¡ La compilazione potrebbe essere terminata senza errori ma senza produrre output" -ForegroundColor Cyan
            exit 1
          }

          $fileSize = (Get-Item "WinToolkit.ps1").Length
          Write-Host "`nâœ… Compilazione completata: $([math]::Round($fileSize/1KB, 2)) KB" -ForegroundColor Green

      # Step 7: Test estesi del file compilato con report errori dettagliato
      - name: Test Estesi WinToolkit Compilato
        id: test_compiled_wintoolkit
        if: steps.check_changes.outputs.has_relevant_changes == 'true'
        shell: pwsh
        run: |
          Write-Host "ğŸ” TEST ESTESI DEL FILE COMPILATO" -ForegroundColor Cyan
          Write-Host "=" * 70 -ForegroundColor Yellow

          $winToolkitPath = "WinToolkit.ps1"

          # Verifica che il file esista
          if (-not (Test-Path $winToolkitPath)) {
            Write-Error "âŒ File WinToolkit.ps1 non trovato"
            exit 1
          }

          Write-Host "ğŸ“‹ Test del file finale: WinToolkit.ps1" -ForegroundColor Green

          $totalErrors = 0
          $totalWarnings = 0
          $testResults = @()
          $criticalErrors = @()

          try {
            $scriptContent = Get-Content -Raw -Path $winToolkitPath -ErrorAction Stop

            # Test 1: Sintassi PowerShell con dettagli completi
            Write-Host "`nğŸ” Test 1: Verifica sintassi..." -ForegroundColor Blue
            $parseErrors = $null
            $tokens = $null
            $null = [System.Management.Automation.Language.Parser]::ParseInput($scriptContent, [ref]$tokens, [ref]$parseErrors)

            if ($parseErrors.Count -gt 0) {
              Write-Host "  âŒ Errori di sintassi trovati:" -ForegroundColor Red
              foreach ($error in $parseErrors) {
                Write-Host "    â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•" -ForegroundColor Red
                Write-Host "    â•‘ ERRORE DI SINTASSI" -ForegroundColor Red
                Write-Host "    â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•" -ForegroundColor Red
                Write-Host "    â•‘ File: WinToolkit.ps1" -ForegroundColor Red
                Write-Host "    â•‘ Linea: $($error.Extent.StartLineNumber)" -ForegroundColor Red
                Write-Host "    â•‘ Colonna: $($error.Extent.StartColumnNumber) - $($error.Extent.EndColumnNumber)" -ForegroundColor Red
                Write-Host "    â•‘ Messaggio: $($error.Message)" -ForegroundColor Red
                Write-Host "    â•‘ SeveritÃ : $($error.ErrorId)" -ForegroundColor Red
                Write-Host "    â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•" -ForegroundColor Red
                Write-Host "    â•‘ Codice problematico:" -ForegroundColor Red
                Write-Host "    â•‘ $($error.Extent.Text)" -ForegroundColor Red
                Write-Host "    â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•" -ForegroundColor Red

                $errorMsg = "WinToolkit.ps1 Line $($error.Extent.StartLineNumber): $($error.Message)"
                $criticalErrors += $errorMsg
              }
              $totalErrors += $parseErrors.Count
              $testResults += "âŒ Sintassi: $($parseErrors.Count) errori"
            }
            else {
              Write-Host "  âœ… Sintassi OK" -ForegroundColor Green
              $testResults += "âœ… Sintassi: OK"
            }

            # Test 2: Verifica funzioni disponibili (rilevamento automatico dalla cartella tool)
            Write-Host "`nğŸ” Test 2: Verifica funzioni disponibili..." -ForegroundColor Blue

            # Rilevamento automatico delle funzioni dalla cartella tool/
            $toolFiles = Get-ChildItem -Path "tool" -Filter "*.ps1" -ErrorAction SilentlyContinue | Where-Object { $_.Name -notlike "*start-*" }
            $expectedFunctions = $toolFiles | ForEach-Object { [System.IO.Path]::GetFileNameWithoutExtension($_.Name) }

            # Parse del file compilato per trovare le funzioni
            $scriptAst = [System.Management.Automation.Language.Parser]::ParseInput($scriptContent, [ref]$null, [ref]$null)
            $functions = $scriptAst.FindAll({ $args[0] -is [System.Management.Automation.Language.FunctionDefinitionAst] }, $true)

            $presentFunctions = @()
            $missingFunctions = @()
            $emptyFunctions = @()

            foreach ($funcName in $expectedFunctions) {
              $funcAst = $functions | Where-Object { $_.Name -eq $funcName }
              if ($funcAst) {
                # Verifica se la funzione Ã¨ vuota (solo dichiarazione senza corpo significativo)
                $bodyText = $funcAst.Body.Extent.Text
                $nonEmptyLines = $bodyText -split "`r?`n" | Where-Object { -not [string]::IsNullOrWhiteSpace($_.Trim()) }
                # Considera vuota se ha 2 o meno righe (dichiarazione function + { + })
                if ($nonEmptyLines.Count -le 2) {
                  $emptyFunctions += $funcName
                }
                else {
                  $presentFunctions += $funcName
                }
              }
              else {
                $missingFunctions += $funcName
              }
            }

            Write-Host "  ğŸ“Š Funzioni attese dalla cartella tool/: $($expectedFunctions.Count)" -ForegroundColor Cyan
            Write-Host "  ğŸ“Š Funzioni presenti e compilate: $($presentFunctions.Count)" -ForegroundColor Green
            if ($presentFunctions.Count -gt 0) {
              $presentFunctions | ForEach-Object { Write-Host "    âœ… $_" -ForegroundColor Green }
            }

            if ($emptyFunctions.Count -gt 0) {
              Write-Host "  âš ï¸ Funzioni vuote (solo dichiarazione, in sviluppo):" -ForegroundColor Yellow
              $emptyFunctions | ForEach-Object { Write-Host "    ğŸ”¶ $_" -ForegroundColor Yellow }
              $testResults += "âš ï¸ Funzioni vuote: $($emptyFunctions.Count) (in sviluppo)"
            }

            if ($missingFunctions.Count -gt 0) {
              Write-Host "  âš ï¸ Funzioni non compilate (file tool/ non nel template):" -ForegroundColor Yellow
              $missingFunctions | ForEach-Object { Write-Host "    âŒ $_" -ForegroundColor Yellow }
              $testResults += "âš ï¸ Funzioni non compilate: $($missingFunctions.Count) (verificare template)"
            }

            if ($presentFunctions.Count -eq $expectedFunctions.Count) {
              Write-Host "  âœ… Tutte le funzioni implementate e compilate correttamente" -ForegroundColor Green
              $testResults += "âœ… Funzioni: Tutte presenti e compilate"
            }
            else {
              Write-Host "  â„¹ï¸ Funzioni rilevate automaticamente dalla cartella tool/" -ForegroundColor Cyan
              $testResults += "â„¹ï¸ Funzioni auto-rilevate: $($presentFunctions.Count)/$($expectedFunctions.Count)"
            }

            # Aggiorna il conteggio warnings per le funzioni vuote
            $totalWarnings += $emptyFunctions.Count

            # Test 3: Struttura del menu
            Write-Host "`nğŸ” Test 3: Verifica struttura menu..." -ForegroundColor Blue
            $menuTests = @(
              @{ Pattern = [regex]::Escape("while (`$true)"); Name = "Menu principale" },
              @{ Pattern = "Windows & Office"; Name = "Categoria Windows & Office" },
              @{ Pattern = "Driver & Gaming"; Name = "Categoria Driver & Gaming" },
              @{ Pattern = "Supporto"; Name = "Categoria Supporto" }
            )

            foreach ($test in $menuTests) {
              if ($scriptContent -match $test.Pattern) {
                Write-Host "  âœ… $($test.Name)" -ForegroundColor Green
                $testResults += "âœ… $($test.Name)"
              }
              else {
                Write-Host "  âŒ $($test.Name) mancante" -ForegroundColor Red
                $totalErrors++
                $testResults += "âŒ $($test.Name) mancante"
                $criticalErrors += "Struttura menu: $($test.Name) mancante"
              }
            }

            # Test 4: Dimensione del file
            Write-Host "`nğŸ” Test 4: Verifica dimensione file..." -ForegroundColor Blue
            $fileSize = (Get-Item $winToolkitPath).Length
            $fileSizeKB = [math]::Round($fileSize/1KB, 2)

            if ($fileSize -lt 10000) {
              Write-Host "  âŒ File troppo piccolo: $($fileSize) bytes" -ForegroundColor Red
              $totalErrors++
              $testResults += "âŒ Dimensione: $fileSizeKB KB (troppo piccolo)"
              $criticalErrors += "Dimensione file sospetta: $fileSizeKB KB (minimo atteso: ~10 KB)"
            }
            else {
              Write-Host "  âœ… Dimensione OK: $fileSizeKB KB" -ForegroundColor Green
              $testResults += "âœ… Dimensione: $fileSizeKB KB"
            }

            # Test 5: Encoding UTF-8
            Write-Host "`nğŸ” Test 5: Verifica encoding..." -ForegroundColor Blue
            $encoding = [System.Text.Encoding]::GetEncoding('UTF-8')
            $preamble = $encoding.GetPreamble()
            $fileBytes = Get-Content $winToolkitPath -AsByteStream -ReadCount 0

            if ($fileBytes.Length -ge 3 -and $fileBytes[0] -eq $preamble[0] -and $fileBytes[1] -eq $preamble[1] -and $fileBytes[2] -eq $preamble[2]) {
              Write-Host "  âœ… Encoding UTF-8 con BOM" -ForegroundColor Green
              $testResults += "âœ… Encoding: UTF-8 con BOM"
            }
            else {
              Write-Host "  âš ï¸ Encoding senza BOM (accettabile)" -ForegroundColor Yellow
              $testResults += "âš ï¸ Encoding: Senza BOM"
            }

          }
          catch {
            $errorMsg = "ERRORE DURANTE I TEST"
            Write-Host "    â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•" -ForegroundColor Red
            Write-Host "    â•‘ $errorMsg" -ForegroundColor Red
            Write-Host "    â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•" -ForegroundColor Red
            Write-Host "    â•‘ Messaggio: $($_.Exception.Message)" -ForegroundColor Red
            Write-Host "    â•‘ Tipo: $($_.Exception.GetType().FullName)" -ForegroundColor Red
            if ($_.InvocationInfo) {
              Write-Host "    â•‘ Linea: $($_.InvocationInfo.ScriptLineNumber)" -ForegroundColor Red
              Write-Host "    â•‘ Comando: $($_.InvocationInfo.Line)" -ForegroundColor Red
            }
            Write-Host "    â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•" -ForegroundColor Red

            $totalErrors++
            $criticalErrors += "Test Error: $($_.Exception.Message)"
            $testResults += "âŒ Errore test: $($_.Exception.Message)"
          }

          # Output risultati test
          Write-Host ""
          Write-Host "ğŸ“Š RIEPILOGO TEST:" -ForegroundColor Cyan
          $testResults | ForEach-Object { Write-Host "  $_" -ForegroundColor Gray }

          # Valuta i risultati: procedi sempre se non ci sono errori di sintassi/struttura
          # Le funzioni mancanti sono normali durante lo sviluppo e non bloccano il workflow
          if ($totalErrors -gt 0) {
            Write-Host "`nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—" -ForegroundColor Red
            Write-Host "â•‘           âŒ TEST FALLITI                             â•‘" -ForegroundColor Red
            Write-Host "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•" -ForegroundColor Red
            Write-Host "`nğŸ“‹ ERRORI CRITICI RILEVATI: $totalErrors" -ForegroundColor Red

            if ($criticalErrors.Count -gt 0) {
              Write-Host "`nğŸ” DETTAGLI ERRORI:" -ForegroundColor Yellow
              foreach ($error in $criticalErrors) {
                Write-Host $error -ForegroundColor Red
              }
            }

            Write-Host "`nğŸ’¡ Suggerimenti:" -ForegroundColor Cyan
            Write-Host "  â€¢ Verifica la sintassi del file compilato" -ForegroundColor White
            Write-Host "  â€¢ Controlla i file sorgenti in /tool per errori logici" -ForegroundColor White
            Write-Host "  â€¢ Assicurati che il template sia corretto" -ForegroundColor White

            Write-Output "tests_passed=false" >> $env:GITHUB_OUTPUT
            exit 1
          }
          else {
            Write-Host "`nâœ… TUTTI I TEST SUPERATI!" -ForegroundColor Green
            if ($emptyFunctions.Count -gt 0) {
              Write-Host "â„¹ï¸ Nota: $($emptyFunctions.Count) funzioni vuote (in sviluppo)" -ForegroundColor Yellow
            }
            Write-Output "tests_passed=true" >> $env:GITHUB_OUTPUT
          }

      # Step 6: Commit automatico del file compilato (solo se i test passano)
      - name: Commit WinToolkit.ps1
        if: steps.check_changes.outputs.has_relevant_changes == 'true' && steps.test_compiled_wintoolkit.outputs.tests_passed == 'true'
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: |
            ğŸ”§ Update WinToolkit.ps1 - Auto-compiled and tested

            â€¢ Compilazione automatica da file in /tool
            â€¢ Test di sintassi e struttura passati
            â€¢ Funzioni rilevate automaticamente dalla cartella tool/
            â€¢ File aggiornato e funzionale
          file_pattern: WinToolkit.ps1
          branch: Dev

      # Step 7: Output finale del workflow
      - name: Risultato Workflow
        shell: pwsh
        run: |
          Write-Host ""
          Write-Host "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—" -ForegroundColor Green
          Write-Host "â•‘                 ğŸ‰ WORKFLOW COMPLETATO!                  â•‘" -ForegroundColor Green
          Write-Host "â•‘                                                          â•‘" -ForegroundColor White

          if ("${{ steps.check_changes.outputs.has_relevant_changes }}" -eq "true") {
            Write-Host "â•‘  âœ… Modifiche rilevanti rilevate                         â•‘" -ForegroundColor Green
            Write-Host "â•‘  ğŸ”¨ Compilazione eseguita                               â•‘" -ForegroundColor Green

            if ("${{ steps.test_compiled_wintoolkit.outputs.tests_passed }}" -eq "true") {
              Write-Host "â•‘  âœ… Tutti i test superati                               â•‘" -ForegroundColor Green
              Write-Host "â•‘  ğŸ“ Commit automatico eseguito                          â•‘" -ForegroundColor Green
              Write-Host "â•‘                                                         â•‘" -ForegroundColor White
              Write-Host "â•‘  ğŸš€ WinToolkit.ps1 aggiornato e pronto!                 â•‘" -ForegroundColor Cyan
            }
            else {
              Write-Host "â•‘  âŒ Test falliti - commit non eseguito                  â•‘" -ForegroundColor Red
              Write-Host "â•‘                                                         â•‘" -ForegroundColor White
              Write-Host "â•‘  ğŸ’¡ Verifica i dettagli degli errori sopra              â•‘" -ForegroundColor Cyan
            }
          }
          else {
            Write-Host "â•‘  â„¹ï¸ Nessuna modifica rilevante                          â•‘" -ForegroundColor Yellow
            Write-Host "â•‘  â­ï¸ Workflow completato senza azioni                   â•‘" -ForegroundColor Yellow
          }

          Write-Host "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•" -ForegroundColor Green
